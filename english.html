<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Language" content="ja" />
</head>
<title>Search time rolling blackouts for Japan</title>
<meta name="description" content="Search time rolling blackouts for Earthquake on Japan (11, Mar 2011)">
<meta name="keywords" content="search,time,rolling,blackouts,earthquake,japan,tepco,tohoku,denryoku,power">
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta http-equiv="Content-Script-Type" content="text/javascript" />
<style type="text/css"> 
@charset "UTF-8";
//reset html {
color:#000;
background:#FFF;
}
body, div, dl, dt, dd, ul, ol, li, h1, h2, h3, h4, h5, h6, pre, code, form, fieldset, legend, input, textarea, p, blockquote, th, td {
	margin:0;
	padding:0;
}
table {
	border-collapse:collapse;
	border-spacing:0;
}
fieldset, img {
	border:0;
}
address, caption, cite, code, dfn, em, strong, th, var {
	font-style:normal;
	font-weight:normal;
}
li {
	list-style:none;
}
caption, th {
	text-align:left;
}
h1, h2, h3, h4, h5, h6 {
	font-size:100%;
	font-weight:normal;
}
q:before, q:after {
	content:'';
}
abbr, acronym {
	border:0;
	font-variant:normal;
}
sup {
	vertical-align:text-top;
}
sub {
	vertical-align:text-bottom;
}
input, textarea, select {
	font-family:inherit;
	font-size:inherit;
	font-weight:inherit;
}
input, textarea, select {
*font-size:100%;
}
legend {
	color:#000;
}
body {
	font-size: 16px;
	font-family: "ヒラギノ角ゴ Pro W3", "Hiragino Kaku Gothic Pro", "メイリオ", Meiryo, Osaka, "ＭＳ Ｐゴシック", "MS PGothic", sans-serif;
}
div#wrapper {
	width: 760px;
	margin-top: 0px;
	margin-right: auto;
	margin-bottom: 0px;
	margin-left: auto;
}
div#header {
	width: 100%;
}
h1 {
	font-size: 1.4em;
	text-align: center;
	display: block;
	margin-top: 3px;
	margin-bottom: 4px;
}
span#ver {
	font-size: 0.6em;
}
div#about {
	width: 100%;
	margin-top: 5px;
	margin-bottom: 7px;
	font-size: 0.8em;
}
div#other {
	width: 100%;
	margin-top: 4px;
	margin-bottom: 4px;
	padding-top: 2px;
	padding-bottom: 2px;
	text-align: right;
}
div#sArea {
	/* [disabled]float: left;
*/
	margin-bottom: 7px;
}
div#explain {
	width: 100%;
	margin-bottom: 7px;
}
div#sAreaL, div#sAreaR {
	width:340px;
	float:left;
	color: #000;
	padding-top: 0;
	padding-right: 15px;
	padding-bottom: 0;
	padding-left: 15px;
}
div#sArea h2 {
	margin-bottom: 6px;
}
ul#otherService {
	margin-top: 20px;
}
ul#otherService li {
	float: left;
}
ul#otherService li a[href] {
	display: block;
	margin-right: 10px;
}
span.h2List {
	color: #F90;
}
div.miList {
	width:50%;
	float:left;
	margin-bottom: 3px;
}
div#sArea {
	padding: 10px;
	background-color: #9DCEF5;
	font-size: 0.9em;
	line-height: 1.6em;
	margin-top: 3px;
	float: left;
}
input#city {
	padding: 1px;
	width: 100%;
	font-size: 1.2em;
	border: 1px solid #F90;
}
input.zip {
	padding: 2px;
	font-size: 1.2em;
	width: 100px;
	border: 1px solid #F90;
}
p.notice {
	font-size: 0.9em;
	margin-bottom: 10px;
	padding-top: 3px;
	padding-bottom: 3px;
}
div#sAreaR label {
	display: block;
	float: left;
	margin-right: 7px;
	width: 45%;
	margin-bottom: 3px;
	padding: 2px;
}
div#submitArea {
	text-align: center;
	width: 680px;
}
div#submitArea input {
	padding: 5px;
	width: 200px;
	margin-top: 10px;
	margin-right: auto;
	margin-bottom: 0px;
	margin-left: auto;
}
ul#tList li {
	display: block;
	float: left;
	margin-bottom: 5px;
	margin-right: 20px;
	list-style-type: decimal;
	list-style-position: inside;
}
div#supported {
	margin-top: 5px;
	clear: both;
	float: left;
	width: 100%;
	margin-bottom: 20px;
}
ul#supporter li {
	font-size: 0.7em;
	float: left;
	margin-right: 7px;
}
ul#thList li {
	margin: 0px;
	padding: 0px;
}
div.mrExp, div.mrHelp {
	width: 95%;
	margin-top: 10px;
	margin-right: auto;
	margin-bottom: 10px;
	margin-left: auto;
	padding: 5px;
	line-height: 1.4em;
	font-size: 0.9em;
}
div.TabbedPanelsContent h3 {
	font-weight: bold;
	text-decoration: underline;
	margin-top: 3px;
	margin-bottom: 3px;
}
ul#update li, ul#engine li, ul#wishList li {
	font-size: 0.9em;
	list-style-position: inside;
	list-style-type: disc;
	margin-left: 1em;
}
div#qrArea {
	clear: both;
	float: left;
	width: 100%;
	margin-bottom: 10px;
	margin-top: 10px;
}
div#qr {
	background-color: #CCC;
	float: left;
	height: 100px;
	width: 100px;
	margin-right: 10px;
}
div#qrcode {
	clear: both;
	width: 100%;
	margin-top: 10px;
}
div#header {
	clear: both;
	width: 100%;
	margin-top: 10px;
}
div#footer {
	clear: both;
	width: 100%;
	margin-top: 10px;
}
div#fileset {
	clear: both;
	width: 100%;
	margin-top: 10px;
}
div#fileset p {
	font-size: 0.95em;
}
div#copyright {
	clear: both;
	float: left;
	margin-top: 10px;
	width: 100%;
}
div#copyright > ul > li {
	clear: both;
	float: left;
}
p.notice {
	margin-top: 5px;
	margin-bottom: 5px;
	clear: both;
	float: left;
}
 @charset "UTF-8";
div#zip {
	margin-top: 7px;
}
div.clear {
	clear: both;
}
/* SpryTabbedPanels.css - version 0.6 - Spry Pre-Release 1.6.1 */
 
/* Copyright (c) 2006. Adobe Systems Incorporated. All rights reserved. */
 
/* Horizontal Tabbed Panels
 
 
 
 The default style for a TabbedPanels widget places all tab buttons
 
 (left aligned) above the content panel.
 */
 
/* This is the selector for the main TabbedPanels container. For our
 
 default style, this container does not contribute anything visually,
 
 but it is floated left to make sure that any floating or clearing done
 
 with any of its child elements are contained completely within the
 
 TabbedPanels container, to minimize any impact or undesireable
 
 interaction with other floated elements on the page that may be used
 
 for layout.
 
 
 
 If you want to constrain the width of the TabbedPanels widget, set a
 
 width on the TabbedPanels container. By default, the TabbedPanels widget
 
 expands horizontally to fill up available space.
 
 
 
 The name of the class ("TabbedPanels") used in this selector is not
 
 necessary to make the widget function. You can use any class name you
 
 want to style the TabbedPanels container.
 */
.TabbedPanels {
	overflow: hidden;
	margin: 0px;
	padding: 0px;
	clear: none;
	width: 100%; /* IE Hack to force proper layout when preceded by a paragraph. (hasLayout Bug)*/
}
/* This is the selector for the TabGroup. The TabGroup container houses
 
 all of the tab buttons for each tabbed panel in the widget. This container
 
 does not contribute anything visually to the look of the widget for our
 
 default style.
 
 
 
 The name of the class ("TabbedPanelsTabGroup") used in this selector is not
 
 necessary to make the widget function. You can use any class name you
 
 want to style the TabGroup container.
 */
.TabbedPanelsTabGroup {
	margin: 0px;
	padding: 0px;
}
/* This is the selector for the TabbedPanelsTab. This container houses
 
 the title for the panel. This is also the tab "button" that the user clicks
 
 on to activate the corresponding content panel so that it appears on top
 
 of the other tabbed panels contained in the widget.
 
 
 
 For our default style, each tab is positioned relatively 1 pixel down from
 
 where it wold normally render. This allows each tab to overlap the content
 
 panel that renders below it. Each tab is rendered with a 1 pixel bottom
 
 border that has a color that matches the top border of the current content
 
 panel. This gives the appearance that the tab is being drawn behind the
 
 content panel.
 
 
 
 The name of the class ("TabbedPanelsTab") used in this selector is not
 
 necessary to make the widget function. You can use any class name you want
 
 to style this tab container.
 */
.TabbedPanelsTab {
	position: relative;
	top: 1px;
	float: left;
	padding: 4px 10px;
	margin: 0px 1px 0px 0px;
	font: bold 0.7em sans-serif;
	background-color: #9DCEF5;
	list-style: none;
	border-left: solid 1px #CCC;
	border-bottom: solid 1px #999;
	border-top: solid 1px #999;
	border-right: solid 1px #999;
	-moz-user-select: none;
	-khtml-user-select: none;
	cursor: pointer;
}
/* This selector is an example of how to change the appearnce of a tab button
 
 container as the mouse enters it. The class "TabbedPanelsTabHover" is
 
 programatically added and removed from the tab element as the mouse enters
 
 and exits the container.
 */
.TabbedPanelsTabHover {
	background-color: #FC0;
}
/* This selector is an example of how to change the appearance of a tab button
 
 container after the user has clicked on it to activate a content panel.
 
 The class "TabbedPanelsTabSelected" is programatically added and removed
 
 from the tab element as the user clicks on the tab button containers in
 
 the widget.
 
 
 
 As mentioned above, for our default style, tab buttons are positioned
 
 1 pixel down from where it would normally render. When the tab button is
 
 selected, we change its bottom border to match the background color of the
 
 content panel so that it looks like the tab is part of the content panel.
 */
.TabbedPanelsTabSelected {
	background-color: #FFF;
	border-bottom: 1px solid #EEE;
}
/* This selector is an example of how to make a link inside of a tab button
 
 look like normal text. Users may want to use links inside of a tab button
 
 so that when it gets focus, the text 
inside
 the tab button gets a focus
 
 ring around it, instead of the focus ring around the entire tab.
 */
.TabbedPanelsTab a {
	color: black;
	text-decoration: none;
}
/* This is the selector for the ContentGroup. The ContentGroup container houses
 
 all of the content panels for each tabbed panel in the widget. For our
 
 default style, this container provides the background color and borders that
 
 surround the content.
 
 
 
 The name of the class ("TabbedPanelsContentGroup") used in this selector is
 
 not necessary to make the widget function. You can use any class name you
 
 want to style the ContentGroup container.
 */
.TabbedPanelsContentGroup {
	clear: both;
	border-left: solid 1px #CCC;
	border-bottom: solid 1px #CCC;
	border-top: solid 1px #999;
	border-right: solid 1px #999;
	background-color: #FFF;
}
/* This is the selector for the Content panel. The Content panel holds the
 
 content for a single tabbed panel. For our default style, this container
 
 provides some padding, so that the content is not pushed up against the
 
 widget borders.
 
 
 
 The name of the class ("TabbedPanelsContent") used in this selector is
 
 not necessary to make the widget function. You can use any class name you
 
 want to style the Content container.
 */
.TabbedPanelsContent {
	overflow: hidden;
	padding-top: 4px;
	padding-right: 14px;
	padding-bottom: 4px;
	padding-left: 14px;
}
/* This selector is an example of how to change the appearnce of the currently
 
 active container panel. The class "TabbedPanelsContentVisible" is
 
 programatically added and removed from the content element as the panel
 
 is activated/deactivated.
 */
.TabbedPanelsContentVisible {
}
/* Vertical Tabbed Panels
 
 
 
 The following rules override some of the default rules above so that the
 
 TabbedPanels widget renders with its tab buttons along the left side of
 
 the currently active content panel.
 
 
 
 With the rules defined below, the only change that will have to be made
 
 to switch a horizontal tabbed panels widget to a vertical tabbed panels
 
 widget, is to use the "VTabbedPanels" class on the top-level widget
 
 container element, instead of "TabbedPanels".
 */
 
.VTabbedPanels {
	overflow: hidden;
	zoom: 1;
}
/* This selector floats the TabGroup so that the tab buttons it contains
 
 render to the left of the active content panel. A border is drawn around
 
 the group container to make it look like a list container.
 */
.VTabbedPanels .TabbedPanelsTabGroup {
	float: left;
	width: 10em;
	height: 20em;
	background-color: #FFF;
	position: relative;
	border-top: solid 1px #999;
	border-right: solid 1px #999;
	border-left: solid 1px #CCC;
	border-bottom: solid 1px #CCC;
}
/* This selector disables the float property that is placed on each tab button
 
 by the default TabbedPanelsTab selector rule above. It also draws a bottom
 
 border for the tab. The tab button will get its left and right border from
 
 the TabGroup, and its top border from the TabGroup or tab button above it.
 */
.VTabbedPanels .TabbedPanelsTab {
	float: none;
	margin: 0px;
	border-top: none;
	border-left: none;
	border-right: none;
}
/* This selector disables the float property that is placed on each tab button
 
 by the default TabbedPanelsTab selector rule above. It also draws a bottom
 
 border for the tab. The tab button will get its left and right border from
 
 the TabGroup, and its top border from the TabGroup or tab button above it.
 */
.VTabbedPanels .TabbedPanelsTabSelected {
	background-color: #EEE;
	border-bottom: solid 1px #999;
}
/* This selector floats the content panels for the widget so that they
 
 render to the right of the tabbed buttons.
 */
.VTabbedPanels .TabbedPanelsContentGroup {
	clear: none;
	float: left;
	padding: 0px;
	width: 30em;
	height: 20em;
}
 
/* Styles for Printing */
@media print {
.TabbedPanels {
	overflow: visible !important;
}
.TabbedPanelsContentGroup {
	display: block !important;
	overflow: visible !important;
	height: auto !important;
}
.TabbedPanelsContent {
	overflow: visible !important;
	display: block !important;
	clear:both !important;
}
.TabbedPanelsTab {
	overflow: visible !important;
	display: block !important;
	clear:both !important;
}
div#TabbedPanels1 {
	/* [disabled]clear: both;
*/
	/* [disabled]float: left;
*/
}
.AccordionPanelTab {
	border: 1px solid #333;
	padding: 1px;
	display: block;
}
</style>
<script type="text/javascript"> 
// SpryTabbedPanels.js - version 0.7 - Spry Pre-Release 1.6.1
//
// Copyright (c) 2006. Adobe Systems Incorporated.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//   * Redistributions of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//   * Redistributions in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//   * Neither the name of Adobe Systems Incorporated nor the names of its
//     contributors may be used to endorse or promote products derived from this
//     software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
 
(function() { // BeginSpryComponent
 
if (typeof Spry == "undefined") window.Spry = {}; if (!Spry.Widget) Spry.Widget = {};
 
Spry.Widget.TabbedPanels = function(element, opts)
{
	this.element = this.getElement(element);
	this.defaultTab = 0; // Show the first panel by default.
	this.tabSelectedClass = "TabbedPanelsTabSelected";
	this.tabHoverClass = "TabbedPanelsTabHover";
	this.tabFocusedClass = "TabbedPanelsTabFocused";
	this.panelVisibleClass = "TabbedPanelsContentVisible";
	this.focusElement = null;
	this.hasFocus = false;
	this.currentTabIndex = 0;
	this.enableKeyboardNavigation = true;
	this.nextPanelKeyCode = Spry.Widget.TabbedPanels.KEY_RIGHT;
	this.previousPanelKeyCode = Spry.Widget.TabbedPanels.KEY_LEFT;
 
	Spry.Widget.TabbedPanels.setOptions(this, opts);
 
	// If the defaultTab is expressed as a number/index, convert
	// it to an element.
 
	if (typeof (this.defaultTab) == "number")
	{
		if (this.defaultTab < 0)
			this.defaultTab = 0;
		else
		{
			var count = this.getTabbedPanelCount();
			if (this.defaultTab >= count)
				this.defaultTab = (count > 1) ? (count - 1) : 0;
		}
 
		this.defaultTab = this.getTabs()[this.defaultTab];
	}
 
	// The defaultTab property is supposed to be the tab element for the tab content
	// to show by default. The caller is allowed to pass in the element itself or the
	// element's id, so we need to convert the current value to an element if necessary.
 
	if (this.defaultTab)
		this.defaultTab = this.getElement(this.defaultTab);
 
	this.attachBehaviors();
};
 
Spry.Widget.TabbedPanels.prototype.getElement = function(ele)
{
	if (ele && typeof ele == "string")
		return document.getElementById(ele);
	return ele;
};
 
Spry.Widget.TabbedPanels.prototype.getElementChildren = function(element)
{
	var children = [];
	var child = element.firstChild;
	while (child)
	{
		if (child.nodeType == 1 /* Node.ELEMENT_NODE */)
			children.push(child);
		child = child.nextSibling;
	}
	return children;
};
 
Spry.Widget.TabbedPanels.prototype.addClassName = function(ele, className)
{
	if (!ele || !className || (ele.className && ele.className.search(new RegExp("\\b" + className + "\\b")) != -1))
		return;
	ele.className += (ele.className ? " " : "") + className;
};
 
Spry.Widget.TabbedPanels.prototype.removeClassName = function(ele, className)
{
	if (!ele || !className || (ele.className && ele.className.search(new RegExp("\\b" + className + "\\b")) == -1))
		return;
	ele.className = ele.className.replace(new RegExp("\\s*\\b" + className + "\\b", "g"), "");
};
 
Spry.Widget.TabbedPanels.setOptions = function(obj, optionsObj, ignoreUndefinedProps)
{
	if (!optionsObj)
		return;
	for (var optionName in optionsObj)
	{
		if (ignoreUndefinedProps && optionsObj[optionName] == undefined)
			continue;
		obj[optionName] = optionsObj[optionName];
	}
};
 
Spry.Widget.TabbedPanels.prototype.getTabGroup = function()
{
	if (this.element)
	{
		var children = this.getElementChildren(this.element);
		if (children.length)
			return children[0];
	}
	return null;
};
 
Spry.Widget.TabbedPanels.prototype.getTabs = function()
{
	var tabs = [];
	var tg = this.getTabGroup();
	if (tg)
		tabs = this.getElementChildren(tg);
	return tabs;
};
 
Spry.Widget.TabbedPanels.prototype.getContentPanelGroup = function()
{
	if (this.element)
	{
		var children = this.getElementChildren(this.element);
		if (children.length > 1)
			return children[1];
	}
	return null;
};
 
Spry.Widget.TabbedPanels.prototype.getContentPanels = function()
{
	var panels = [];
	var pg = this.getContentPanelGroup();
	if (pg)
		panels = this.getElementChildren(pg);
	return panels;
};
 
Spry.Widget.TabbedPanels.prototype.getIndex = function(ele, arr)
{
	ele = this.getElement(ele);
	if (ele && arr && arr.length)
	{
		for (var i = 0; i < arr.length; i++)
		{
			if (ele == arr[i])
				return i;
		}
	}
	return -1;
};
 
Spry.Widget.TabbedPanels.prototype.getTabIndex = function(ele)
{
	var i = this.getIndex(ele, this.getTabs());
	if (i < 0)
		i = this.getIndex(ele, this.getContentPanels());
	return i;
};
 
Spry.Widget.TabbedPanels.prototype.getCurrentTabIndex = function()
{
	return this.currentTabIndex;
};
 
Spry.Widget.TabbedPanels.prototype.getTabbedPanelCount = function(ele)
{
	return Math.min(this.getTabs().length, this.getContentPanels().length);
};
 
Spry.Widget.TabbedPanels.addEventListener = function(element, eventType, handler, capture)
{
	try
	{
		if (element.addEventListener)
			element.addEventListener(eventType, handler, capture);
		else if (element.attachEvent)
			element.attachEvent("on" + eventType, handler);
	}
	catch (e) {}
};
 
Spry.Widget.TabbedPanels.prototype.cancelEvent = function(e)
{
	if (e.preventDefault) e.preventDefault();
	else e.returnValue = false;
	if (e.stopPropagation) e.stopPropagation();
	else e.cancelBubble = true;
 
	return false;
};
 
Spry.Widget.TabbedPanels.prototype.onTabClick = function(e, tab)
{
	this.showPanel(tab);
	return this.cancelEvent(e);
};
 
Spry.Widget.TabbedPanels.prototype.onTabMouseOver = function(e, tab)
{
	this.addClassName(tab, this.tabHoverClass);
	return false;
};
 
Spry.Widget.TabbedPanels.prototype.onTabMouseOut = function(e, tab)
{
	this.removeClassName(tab, this.tabHoverClass);
	return false;
};
 
Spry.Widget.TabbedPanels.prototype.onTabFocus = function(e, tab)
{
	this.hasFocus = true;
	this.addClassName(tab, this.tabFocusedClass);
	return false;
};
 
Spry.Widget.TabbedPanels.prototype.onTabBlur = function(e, tab)
{
	this.hasFocus = false;
	this.removeClassName(tab, this.tabFocusedClass);
	return false;
};
 
Spry.Widget.TabbedPanels.KEY_UP = 38;
Spry.Widget.TabbedPanels.KEY_DOWN = 40;
Spry.Widget.TabbedPanels.KEY_LEFT = 37;
Spry.Widget.TabbedPanels.KEY_RIGHT = 39;
 
 
 
Spry.Widget.TabbedPanels.prototype.onTabKeyDown = function(e, tab)
{
	var key = e.keyCode;
	if (!this.hasFocus || (key != this.previousPanelKeyCode && key != this.nextPanelKeyCode))
		return true;
 
	var tabs = this.getTabs();
	for (var i =0; i < tabs.length; i++)
		if (tabs[i] == tab)
		{
			var el = false;
			if (key == this.previousPanelKeyCode && i > 0)
				el = tabs[i-1];
			else if (key == this.nextPanelKeyCode && i < tabs.length-1)
				el = tabs[i+1];
 
			if (el)
			{
				this.showPanel(el);
				el.focus();
				break;
			}
		}
 
	return this.cancelEvent(e);
};
 
Spry.Widget.TabbedPanels.prototype.preorderTraversal = function(root, func)
{
	var stopTraversal = false;
	if (root)
	{
		stopTraversal = func(root);
		if (root.hasChildNodes())
		{
			var child = root.firstChild;
			while (!stopTraversal && child)
			{
				stopTraversal = this.preorderTraversal(child, func);
				try { child = child.nextSibling; } catch (e) { child = null; }
			}
		}
	}
	return stopTraversal;
};
 
Spry.Widget.TabbedPanels.prototype.addPanelEventListeners = function(tab, panel)
{
	var self = this;
	Spry.Widget.TabbedPanels.addEventListener(tab, "click", function(e) { return self.onTabClick(e, tab); }, false);
	Spry.Widget.TabbedPanels.addEventListener(tab, "mouseover", function(e) { return self.onTabMouseOver(e, tab); }, false);
	Spry.Widget.TabbedPanels.addEventListener(tab, "mouseout", function(e) { return self.onTabMouseOut(e, tab); }, false);
 
	if (this.enableKeyboardNavigation)
	{
		// XXX: IE doesn't allow the setting of tabindex dynamically. This means we can't
		// rely on adding the tabindex attribute if it is missing to enable keyboard navigation
		// by default.
 
		// Find the first element within the tab container that has a tabindex or the first
		// anchor tag.
		
		var tabIndexEle = null;
		var tabAnchorEle = null;
 
		this.preorderTraversal(tab, function(node) {
			if (node.nodeType == 1 /* NODE.ELEMENT_NODE */)
			{
				var tabIndexAttr = tab.attributes.getNamedItem("tabindex");
				if (tabIndexAttr)
				{
					tabIndexEle = node;
					return true;
				}
				if (!tabAnchorEle && node.nodeName.toLowerCase() == "a")
					tabAnchorEle = node;
			}
			return false;
		});
 
		if (tabIndexEle)
			this.focusElement = tabIndexEle;
		else if (tabAnchorEle)
			this.focusElement = tabAnchorEle;
 
		if (this.focusElement)
		{
			Spry.Widget.TabbedPanels.addEventListener(this.focusElement, "focus", function(e) { return self.onTabFocus(e, tab); }, false);
			Spry.Widget.TabbedPanels.addEventListener(this.focusElement, "blur", function(e) { return self.onTabBlur(e, tab); }, false);
			Spry.Widget.TabbedPanels.addEventListener(this.focusElement, "keydown", function(e) { return self.onTabKeyDown(e, tab); }, false);
		}
	}
};
 
Spry.Widget.TabbedPanels.prototype.showPanel = function(elementOrIndex)
{
	var tpIndex = -1;
	
	if (typeof elementOrIndex == "number")
		tpIndex = elementOrIndex;
	else // Must be the element for the tab or content panel.
		tpIndex = this.getTabIndex(elementOrIndex);
	
	if (!tpIndex < 0 || tpIndex >= this.getTabbedPanelCount())
		return;
 
	var tabs = this.getTabs();
	var panels = this.getContentPanels();
 
	var numTabbedPanels = Math.max(tabs.length, panels.length);
 
	for (var i = 0; i < numTabbedPanels; i++)
	{
		if (i != tpIndex)
		{
			if (tabs[i])
				this.removeClassName(tabs[i], this.tabSelectedClass);
			if (panels[i])
			{
				this.removeClassName(panels[i], this.panelVisibleClass);
				panels[i].style.display = "none";
			}
		}
	}
 
	this.addClassName(tabs[tpIndex], this.tabSelectedClass);
	this.addClassName(panels[tpIndex], this.panelVisibleClass);
	panels[tpIndex].style.display = "block";
 
	this.currentTabIndex = tpIndex;
};
 
Spry.Widget.TabbedPanels.prototype.attachBehaviors = function(element)
{
	var tabs = this.getTabs();
	var panels = this.getContentPanels();
	var panelCount = this.getTabbedPanelCount();
 
	for (var i = 0; i < panelCount; i++)
		this.addPanelEventListeners(tabs[i], panels[i]);
 
	this.showPanel(this.defaultTab);
};
 
})(); // EndSpryComponent
 
</script>
</head>
<body onload="document.form.city.focus()">
<div id="wrapper">
<div id="other">[<a href="?me">for Mobile</a>] [<a href="?j">Japanese</a>]</div>
<div id="header">
<div id="logo">
<h1>Power failure search tool for Japan <span id="ver">@@VER@@ (TEPCO,Tohoku-Denryoku)</span><br />
<img src="title_eng.jpg" width="300" alt="Power failure search tool for Japan" />
</h1>
</div>
</div>
<div id="about">
<p> It is a tool that can easily retrieve time and the group of the rolling blackout of the influence in the large earthquake that occurred on March 11 in Japan. Can the region where I live able to belong to the group where, and to retrieve it according to part etc. or the ZIP code of the address. </p></div>

<div id="sArea">
<form action="area.cgi" method="get" name="form">
<div id="sAreaL">
<h2><span class="h2List">▶</span>City or AreaName (egg..Tokyo is toukyou, City is shi....Roman alphabet) or ZIP code. (egg..100-0000 or 1000000)<br />
When can't search, Please use ZIP code.
</h2>
<input type="text" name="city" size="20" id="city" />
</div>
<div id="sAreaR">
<div>
<h2><span class="h2List">▶</span>Narrowing group number</h2>
<label>
Main Group:
<select name="gid">
<option value="0">none</option>
<option value="1">Group 1</option>
<option value="2">Group 2</option>
<option value="3">Group 3</option>
<option value="4">Group 4</option>
<option value="5">Group 5</option>
<option value="6">Group 6 (Tohoku)</option>
<option value="7">Group 7 (Tohoku)</option>
<option value="8">Group 8 (Tohoku</option>
</select>
</label>
<label>
Sub Group:
<select name="gids">
<option value="0">none</option>
<option value="A">Group A (Tepco)</option>
<option value="B">Group B (Tepco)</option>
<option value="C">Group C (Tepco)</option>
<option value="D">Group D (Tepco)</option>
<option value="E">Group E (Tepco)</option>
</select>
</label>
</div>
</div>
<div style="clear:both;" id="submitArea">
<input type="hidden" name="m" value="e" />
<input type="submit" name="submit" value="Search" />
</div>
</form>
</div>
<div id="qrcode">@@QRCODEEN@@</div>
<div id="copyright">
<ul>
<li> To original site (Japanese):<a href="http://bizoole.com/power/">Search time rolling blackouts for Japan</a></li>
<li> by Masahiko Nakajima (pwr (dot) bizoole (at) gmail (dot) com)</li>
</ul>
</div>
<div id="supported">
<ul id="supporter">
<li>Supported by</li>
<li><a href="http://twitter.com/Komotoya">Komotoya</a>&nbsp(by toppage design)</li>
<li><a href="http://twitter.com/10b346">10b346</a>&nbsp;(by SEO)</li>
<li><a href="http://twitter.com/watanabe_haruna">watanabe_haruna</a>&nbsp;(IMG PROPERTY)</li>
</ul>
</div>
<!-- update href="http://power.daiba.cx/@@TARBALL@@" -->
</body>
</html>
